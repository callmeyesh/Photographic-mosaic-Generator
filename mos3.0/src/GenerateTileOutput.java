import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import javax.imageio.ImageIO;


/**
 * @author Yeshwanth Venkatesh
 * 
 * @version 3.0 6th December 2012
 * 
 */

public class GenerateTileOutput {

	/**
	 * 
	 * Create a List of CIELAB co-ordinates for Tiles & Target Images. Generate
	 * mosaic for each row and store in temp directory Generate the mosaic by
	 * sticthing all the rows together Delete the Temp direcotry created
	 * 
	 * 
	 * @return void
	 * */
	public static void GenerateOutput() throws IOException,
			InterruptedException {

		// List containing CIELAB co-ordinates [L*,a,b] for each tile
		List<KdTree.LAB> processedTileRGB = ProcessTile.ProcessTileFiles();
		// List containing CIELAB co-ordinates [L*,a,b] for each grid in target
		// image
		List<KdTree.LAB> processedTargetRGB = ProcessTarget.ProcessTargetFile();
		// Create a KdTree with eahc tile CIELAB co-ordinates [L*,a,b]
		KdTree<KdTree.LAB> kd = new KdTree<KdTree.LAB>(processedTileRGB);
		BufferedImage targetBuffer = ImageIO.read(new File(Main
				.getTARGET_IMG_DIR()));
		// Temp Direcotory to store the each row generated by the ImageMagick's
		// montage command
		File tempDir = File.createTempFile("mosnuic_temp", "");
		
		tempDir.delete();
		tempDir.mkdir();
		
		String tempDirPath = tempDir.getAbsolutePath();
		
		int totalGrid = processedTargetRGB.size();
		nearestNeighbour<KdTree.LAB> neN = new nearestNeighbour<KdTree.LAB>();
		int counter = 0;
		int temp_row_count = 0;
		String finalOutput = "";
		String rowOutput = "";
		
		// Get Reuse Limit specified by the User if any
		int reUSE = Main.getREUSE_LIMIT();
		// For each grid get the nearest CIELAB co-ordinates matching the tile
		// For each row in the target image generate mosaic for that row and
		// store it in temp directory
		try {
			for (int i = 0; i < totalGrid; i++) {
				Collection<KdTree.LAB> result = neN
						.nearestNeighbourSearch(processedTargetRGB.get(i));
				counter++;
				for (KdTree.LAB o : result) {
					int limit = o.getTileLimit();
					String tileName = o.getTileName();
					rowOutput += Main.getTILE_IMG_DIR() + "/" + tileName + " ";
					// If we reached end of the row in the target image
					if ((counter % (targetBuffer.getWidth() / Main
							.getTILEDIMENSION(0))) == 0) {
						counter = 0;
						temp_row_count++;
						File outputfile = new File(tempDirPath + "/row_"
								+ Integer.toString(temp_row_count) + ".jpeg");
						processMosaic.photoMosaic(rowOutput, 1, (targetBuffer
								.getWidth() / Main.getTILEDIMENSION(0)),
								outputfile.toString());
						rowOutput = "";
						finalOutput += outputfile.toString() + " ";
					}
					o.setTileLimit(++limit);
					// if the reuse limit of each tile was reached
					// remove that tile from the KdTree and re create the tree
					if (limit == reUSE) {
						Iterator<KdTree.LAB> k = processedTileRGB.iterator();
						while (k.hasNext()) {
							KdTree.LAB s = k.next();
							if (s.getTileLimit() == reUSE) {
								k.remove();
							}
						}
						kd = new KdTree<KdTree.LAB>(processedTileRGB);
					}
				}
			}
			// Generate the final mosaic by stitching all the rows together
			processMosaic
					.photoMosaic(finalOutput, targetBuffer.getHeight()
							/ Main.getTILEDIMENSION(1), 1, tempDirPath
							+ "/output.jpeg");
			String outputImgFormat = "";			
			//Check the image format for the final output.
			//If the image format is unknown, then it will be same
			//as that of the target image.
			if (Main.getOUTPUT_IMG_FOMRAT().equals("UNKNOWN")) {
				outputImgFormat = Main.getTARGET_IMG_FORMAT();
			}
			//If the output does not have any suffix, then
			//output image format is same as that of the target
			//image.
			else if (Main.getOUTPUT_IMG_FOMRAT().equals("NO_EXT")) {
				outputImgFormat = Main.getTARGET_IMG_FORMAT();
			} 
			//Else, get the image format of the target image.
			else {
				outputImgFormat = Main.getOUTPUT_IMG_FOMRAT();
			}			
			//Generate the final output in the temporary directory.
			processMosaic.jpegToImage(tempDirPath + "/output.jpeg", tempDirPath
					+ "/output." + outputImgFormat);			
			//if the suffix, in the output image is unknown,
			//then rename the output generated in the previous step,
			//to the specified name.
			if (Main.getOUTPUT_IMG_FOMRAT().equals("UNKNOWN")) {
				File output = new File(Main.getOUTPUT_IMG_DIR());
				String parent = output.getParent();
				String out_name = parent + "/output_"
						+ System.currentTimeMillis() + "." + outputImgFormat;				
				processMosaic.jpegToImage(tempDirPath + "/output."
						+ outputImgFormat, out_name);
				File out_dir = new File(Main.getOUTPUT_IMG_DIR());
				File temp_out = new File(out_name);
				if (temp_out.exists()) {
					temp_out.renameTo(out_dir);
				}
			} 
			//else, generate the final output directly, into the
			//specified directory.
			else {
				processMosaic.jpegToImage(tempDirPath + "/output."
						+ outputImgFormat, Main.getOUTPUT_IMG_DIR());
			}
			targetBuffer.flush();
		} catch (Exception e) {
			System.out.println("Error Creating the Mosaic...Sorry.");
		} finally {
			//Delete all the temporary files created by the program.
			deleteFolder(tempDir.getAbsolutePath());
		}
	}

	/**
	 * Delete the temp directories created by the program
	 * during its execution.
	 * 
	 * @return void
	 * */
	public static void deleteFolder(String path) {
		File folder = new File(path);
		File[] files = folder.listFiles();
		if (files != null) {
			for (File f : files) {
				if (f.isDirectory()) {
					deleteFolder(f.getAbsolutePath());
				} else {
					f.delete();
				}
			}
		}
		folder.delete();
	}
}
